"""Statistical Analysis View for crowding metrics and theoretical predictions."""

from __future__ import annotations

import tkinter as tk
from tkinter import ttk, messagebox
from typing import Callable, Optional, Dict, Any

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure

from spectral_playground.gui.state import PlaygroundState
from spectral_playground.core.statistics import (
    RadiusDistribution,
    BooleanModelTheory,
    CrowdingAnalyzer
)


class StatisticsView(ttk.Frame):
    """Statistical analysis dashboard with numbers-first reporting.
    
    Provides controls for configuring analysis parameters, displays
    key metrics in a scoreboard, and shows theoretical vs empirical
    comparisons in plots.
    """
    
    def __init__(
        self,
        parent: tk.Widget,
        state: PlaygroundState,
        log_callback: Callable[[str], None],
        open_inspector_callback: Optional[Callable[[list], None]] = None
    ):
        """Initialize statistics view.
        
        Args:
            parent: Parent widget
            state: Playground state
            log_callback: Function to log messages
            open_inspector_callback: Function to open Inspector with object IDs
        """
        super().__init__(parent)
        self.state = state
        self.log = log_callback
        self.open_inspector = open_inspector_callback
        
        # Analysis results cache
        self.last_results: Optional[Dict[str, Any]] = None
        
        # Configure grid layout: Controls | Scoreboard | Plots
        self.columnconfigure(0, weight=1, minsize=250)
        self.columnconfigure(1, weight=1, minsize=280)
        self.columnconfigure(2, weight=2, minsize=500)
        self.rowconfigure(0, weight=1)
        
        self._build_controls()
        self._build_scoreboard()
        self._build_plots()
        
        # Initialize policy visibility
        self._update_policy_visibility()
    
    def _create_scrollable_frame(self, parent: tk.Widget) -> tuple[tk.Canvas, ttk.Frame]:
        """Helper to create scrollable frame pattern.
        
        Returns:
            Tuple of (canvas, scrollable_frame)
        """
        canvas = tk.Canvas(parent, highlightthickness=0)
        scrollbar = ttk.Scrollbar(parent, orient='vertical', command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            '<Configure>',
            lambda e: canvas.configure(scrollregion=canvas.bbox('all'))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor='nw')
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        return canvas, scrollable_frame
    
    def _build_controls(self) -> None:
        """Build control panel with analysis parameters."""
        controls_frame = ttk.LabelFrame(self, text='Analysis Parameters')
        controls_frame.grid(row=0, column=0, sticky='nsew', padx=4, pady=4)
        
        # Scrollable container
        canvas, scrollable_frame = self._create_scrollable_frame(controls_frame)
        
        # Auto-fit button at top (prominent placement)
        autofit_frame = ttk.Frame(scrollable_frame)
        autofit_frame.pack(fill=tk.X, padx=4, pady=(4, 8))
        
        ttk.Button(
            autofit_frame,
            text='⚙ Auto-Fit All from Scene',
            command=self._auto_fit_from_scene
        ).pack(fill=tk.X)
        
        # Status label for fitted values
        self.fitted_status_label = ttk.Label(
            autofit_frame,
            text='',
            font=('TkDefaultFont', 8),
            foreground='#2a7f2a'
        )
        self.fitted_status_label.pack(anchor='w', pady=(2, 0))
        
        # Policy selection
        policy_frame = ttk.LabelFrame(scrollable_frame, text='Select Overlap Policy')
        policy_frame.pack(fill=tk.X, padx=4, pady=4)
        
        self.active_policy = tk.StringVar(value='overlap')
        self.active_policy.trace_add('write', lambda *args: self._update_policy_visibility())
        
        ttk.Radiobutton(
            policy_frame,
            text='Neighbor Count Policy',
            variable=self.active_policy,
            value='overlap'
        ).pack(anchor='w', padx=4)
        
        ttk.Radiobutton(
            policy_frame,
            text='Region Density Policy',
            variable=self.active_policy,
            value='box'
        ).pack(anchor='w', padx=4)
        
        # Spatial intensity (λ) - shared parameter
        intensity_frame = ttk.LabelFrame(scrollable_frame, text='Spatial Intensity')
        intensity_frame.pack(fill=tk.X, padx=4, pady=4)
        
        ttk.Label(intensity_frame, text='λ (objects per pixel²):').pack(anchor='w', padx=4)
        self.intensity = tk.DoubleVar(value=0.001)
        ttk.Entry(intensity_frame, textvariable=self.intensity, width=12).pack(
            anchor='w', padx=4, pady=(0, 4)
        )
        
        # Neighbor Count Policy parameters
        self.neighbor_frame = ttk.LabelFrame(scrollable_frame, text='Neighbor Count Policy Parameters')
        self.neighbor_frame.pack(fill=tk.X, padx=4, pady=4)
        
        ttk.Label(self.neighbor_frame, text='Neighbor threshold (m):').pack(anchor='w', padx=4)
        self.neighbor_threshold = tk.IntVar(value=2)
        ttk.Spinbox(
            self.neighbor_frame,
            from_=1,
            to=20,
            textvariable=self.neighbor_threshold,
            width=10
        ).pack(anchor='w', padx=4)
        
        ttk.Label(
            self.neighbor_frame,
            text='Discard if ≥ m neighbors overlap',
            font=('TkDefaultFont', 8, 'italic'),
            foreground='#555'
        ).pack(anchor='w', padx=4, pady=(2, 4))
        
        # Region Density Policy parameters
        self.box_frame = ttk.LabelFrame(scrollable_frame, text='Region Density Policy Parameters')
        self.box_frame.pack(fill=tk.X, padx=4, pady=4)
        
        ttk.Label(self.box_frame, text='Box side length (a, pixels):').pack(anchor='w', padx=4)
        self.box_size = tk.IntVar(value=8)
        
        scale = ttk.Scale(
            self.box_frame,
            from_=2,
            to=32,
            variable=self.box_size,
            orient=tk.HORIZONTAL,
            command=lambda _: self._update_box_area_display()
        )
        scale.pack(fill=tk.X, padx=4)
        
        # Show current value and area
        box_value_frame = ttk.Frame(self.box_frame)
        box_value_frame.pack(fill=tk.X, padx=4)
        ttk.Label(box_value_frame, text='a = ').pack(side=tk.LEFT)
        ttk.Label(box_value_frame, textvariable=self.box_size).pack(side=tk.LEFT)
        ttk.Label(box_value_frame, text=' → Box area: ').pack(side=tk.LEFT)
        self.box_area_label = ttk.Label(box_value_frame, text='64 px²', foreground='#2a7f2a')
        self.box_area_label.pack(side=tk.LEFT)
        
        ttk.Label(self.box_frame, text='Occupancy threshold (k₀):').pack(anchor='w', padx=4, pady=(6,0))
        self.box_threshold = tk.IntVar(value=2)
        ttk.Spinbox(
            self.box_frame,
            from_=1,
            to=20,
            textvariable=self.box_threshold,
            width=10
        ).pack(anchor='w', padx=4)
        
        ttk.Label(
            self.box_frame,
            text='Crowded if ≥ k₀ objects in box',
            font=('TkDefaultFont', 8, 'italic'),
            foreground='#555'
        ).pack(anchor='w', padx=4, pady=(2, 6))
        
        ttk.Label(self.box_frame, text='Counting mode:').pack(anchor='w', padx=4, pady=(6,0))
        self.count_mode = tk.StringVar(value='germ')
        ttk.Radiobutton(
            self.box_frame,
            text='Germ (centers only)',
            variable=self.count_mode,
            value='germ'
        ).pack(anchor='w', padx=4)
        ttk.Radiobutton(
            self.box_frame,
            text='Intersection (disc overlap)',
            variable=self.count_mode,
            value='intersection'
        ).pack(anchor='w', padx=4, pady=(0, 4))
        
        # Radius distribution parameters (for theory)
        dist_frame = ttk.LabelFrame(scrollable_frame, text='Radius Distribution')
        dist_frame.pack(fill=tk.X, padx=4, pady=4)
        
        ttk.Label(dist_frame, text='Mean (μ, pixels):').pack(anchor='w', padx=4)
        self.radius_mean = tk.DoubleVar(value=3.0)
        ttk.Entry(dist_frame, textvariable=self.radius_mean, width=10).pack(
            anchor='w', padx=4
        )
        
        ttk.Label(dist_frame, text='Std Dev (σ, pixels):').pack(anchor='w', padx=4, pady=(4, 0))
        self.radius_std = tk.DoubleVar(value=0.6)
        ttk.Entry(dist_frame, textvariable=self.radius_std, width=10).pack(
            anchor='w', padx=4
        )
        
        ttk.Label(dist_frame, text='Min radius (pixels):').pack(anchor='w', padx=4, pady=(4, 0))
        self.radius_min = tk.DoubleVar(value=2.0)
        ttk.Entry(dist_frame, textvariable=self.radius_min, width=10).pack(
            anchor='w', padx=4
        )
        
        ttk.Label(dist_frame, text='Max radius (pixels):').pack(anchor='w', padx=4, pady=(4, 0))
        self.radius_max = tk.DoubleVar(value=5.0)
        ttk.Entry(dist_frame, textvariable=self.radius_max, width=10).pack(
            anchor='w', padx=4, pady=(0, 4)
        )
        
        # Action buttons
        btn_frame = ttk.Frame(scrollable_frame)
        btn_frame.pack(fill=tk.X, padx=4, pady=8)
        
        ttk.Button(
            btn_frame,
            text='Run Analysis',
            command=self._run_analysis
        ).pack(fill=tk.X, pady=2)
        
        ttk.Button(
            btn_frame,
            text='Export Results (CSV)',
            command=self._export_csv
        ).pack(fill=tk.X, pady=2)
    
    def _build_scoreboard(self) -> None:
        """Build numbers-first scoreboard panel."""
        scoreboard_frame = ttk.LabelFrame(self, text='Crowding Metrics')
        scoreboard_frame.grid(row=0, column=1, sticky='nsew', padx=4, pady=4)
        
        # Create scrollable container
        canvas, scrollable_frame = self._create_scrollable_frame(scoreboard_frame)
        
        # Common metrics (always shown)
        common_metrics = [
            ('Total Objects', 'total_objects'),
            ('', ''),  # Separator
        ]
        
        # Policy-specific metrics (will be shown/hidden)
        self.neighbor_metrics = [
            ('Discarded Objects', 'discarded_by_object'),
            ('', ''),  # Separator
        ]
        
        self.box_metrics = [
            ('Crowded Boxes', 'crowded_boxes'),
            ('Discarded Objects', 'discarded_by_box'),
            ('', ''),  # Separator
        ]
        
        # Shared result metrics
        result_metrics = [
            ('Isolated Objects', 'isolated_objects'),
            ('Isolated/Area (per px²)', 'good_per_area_strict'),
            ('', ''),  # Separator
            ('Coverage Fraction', 'coverage_fraction'),
        ]
        
        self.metric_labels = {}
        self.metric_rows = {}  # Track which row each metric is on
        
        row = 0
        
        # Add common metrics
        for name, key in common_metrics:
            if not name:
                ttk.Separator(scrollable_frame, orient='horizontal').grid(
                    row=row, column=0, columnspan=2, sticky='ew', pady=4
                )
                row += 1
                continue
            
            ttk.Label(
                scrollable_frame,
                text=name + ':',
                font=('TkDefaultFont', 10)
            ).grid(row=row, column=0, sticky='w', padx=4, pady=2)
            
            val_label = ttk.Label(
                scrollable_frame,
                text='—',
                font=('TkDefaultFont', 12, 'bold')
            )
            val_label.grid(row=row, column=1, sticky='e', padx=4, pady=2)
            
            if key:
                self.metric_labels[key] = val_label
            row += 1
        
        # Neighbor policy specific metrics (with frame for easy show/hide)
        self.neighbor_metrics_frame = ttk.Frame(scrollable_frame)
        self.neighbor_metrics_frame.grid(row=row, column=0, columnspan=2, sticky='ew')
        
        metric_row = 0
        for name, key in self.neighbor_metrics:
            if not name:
                ttk.Separator(self.neighbor_metrics_frame, orient='horizontal').grid(
                    row=metric_row, column=0, columnspan=2, sticky='ew', pady=4
                )
                metric_row += 1
                continue
            
            ttk.Label(
                self.neighbor_metrics_frame,
                text=name + ':',
                font=('TkDefaultFont', 10)
            ).grid(row=metric_row, column=0, sticky='w', padx=4, pady=2)
            
            val_label = ttk.Label(
                self.neighbor_metrics_frame,
                text='—',
                font=('TkDefaultFont', 12, 'bold')
            )
            val_label.grid(row=metric_row, column=1, sticky='e', padx=4, pady=2)
            
            if key:
                self.metric_labels[key] = val_label
            metric_row += 1
        
        row += 1
        
        # Box policy specific metrics (with frame for easy show/hide)
        self.box_metrics_frame = ttk.Frame(scrollable_frame)
        self.box_metrics_frame.grid(row=row, column=0, columnspan=2, sticky='ew')
        
        metric_row = 0
        for name, key in self.box_metrics:
            if not name:
                ttk.Separator(self.box_metrics_frame, orient='horizontal').grid(
                    row=metric_row, column=0, columnspan=2, sticky='ew', pady=4
                )
                metric_row += 1
                continue
            
            ttk.Label(
                self.box_metrics_frame,
                text=name + ':',
                font=('TkDefaultFont', 10)
            ).grid(row=metric_row, column=0, sticky='w', padx=4, pady=2)
            
            val_label = ttk.Label(
                self.box_metrics_frame,
                text='—',
                font=('TkDefaultFont', 12, 'bold')
            )
            val_label.grid(row=metric_row, column=1, sticky='e', padx=4, pady=2)
            
            if key:
                self.metric_labels[key] = val_label
            metric_row += 1
        
        row += 1
        
        # Add result metrics
        for name, key in result_metrics:
            if not name:
                ttk.Separator(scrollable_frame, orient='horizontal').grid(
                    row=row, column=0, columnspan=2, sticky='ew', pady=4
                )
                row += 1
                continue
            
            ttk.Label(
                scrollable_frame,
                text=name + ':',
                font=('TkDefaultFont', 10)
            ).grid(row=row, column=0, sticky='w', padx=4, pady=2)
            
            val_label = ttk.Label(
                scrollable_frame,
                text='—',
                font=('TkDefaultFont', 12, 'bold')
            )
            val_label.grid(row=row, column=1, sticky='e', padx=4, pady=2)
            
            if key:
                self.metric_labels[key] = val_label
            row += 1
        
        # Theory comparison section
        theory_frame = ttk.LabelFrame(scrollable_frame, text='Theory vs Empirical')
        theory_frame.grid(row=row, column=0, columnspan=2, sticky='ew', padx=4, pady=8)
        
        theory_metrics = [
            ('Expected Isolated', 'expected_good'),
            ('Actual Isolated', 'actual_good'),
        ]
        
        for i, (name, key) in enumerate(theory_metrics):
            ttk.Label(
                theory_frame,
                text=name + ':',
                font=('TkDefaultFont', 9)
            ).grid(row=i, column=0, sticky='w', padx=4, pady=1)
            
            val_label = ttk.Label(
                theory_frame,
                text='—',
                font=('TkDefaultFont', 10, 'bold')
            )
            val_label.grid(row=i, column=1, sticky='e', padx=4, pady=1)
            
            if key:
                self.metric_labels[key] = val_label
        
        row += 1
        
        # Inspector buttons
        inspector_frame = ttk.LabelFrame(scrollable_frame, text='Inspect Objects')
        inspector_frame.grid(row=row, column=0, columnspan=2, sticky='ew', padx=4, pady=8)
        
        ttk.Button(
            inspector_frame,
            text='View Overlapping Objects',
            command=self._view_discarded
        ).pack(fill=tk.X, padx=4, pady=2)
        
        ttk.Button(
            inspector_frame,
            text='View Isolated Objects',
            command=self._view_good
        ).pack(fill=tk.X, padx=4, pady=2)
    
    def _build_plots(self) -> None:
        """Build plots panel with overlap probability analysis."""
        plots_frame = ttk.LabelFrame(self, text='Analysis Plots')
        plots_frame.grid(row=0, column=2, sticky='nsew', padx=4, pady=4)
        
        # Create matplotlib figure with 3 subplots
        self.figure = Figure(figsize=(7, 10), dpi=100)
        self.figure.subplots_adjust(hspace=0.35, left=0.13, right=0.95, top=0.96, bottom=0.06)
        
        # Plot 1: Survival probability vs intensity
        self.ax_survival_lambda = self.figure.add_subplot(311)
        self.ax_survival_lambda.set_title('Survival Probability vs Intensity')
        self.ax_survival_lambda.set_xlabel('Intensity λ (objects per px²)')
        self.ax_survival_lambda.set_ylabel('P(survive)')
        self.ax_survival_lambda.grid(True, alpha=0.3)
        
        # Plot 2: Survival probability vs threshold
        self.ax_survival_threshold = self.figure.add_subplot(312)
        self.ax_survival_threshold.set_title('Survival Probability vs Threshold')
        self.ax_survival_threshold.set_xlabel('Threshold parameter')
        self.ax_survival_threshold.set_ylabel('P(survive)')
        self.ax_survival_threshold.grid(True, alpha=0.3)
        
        # Plot 3: Isolated objects vs density
        self.ax_isolated_count = self.figure.add_subplot(313)
        self.ax_isolated_count.set_title('Isolated Objects vs Density')
        self.ax_isolated_count.set_xlabel('Total Objects (n)')
        self.ax_isolated_count.set_ylabel('Isolated Objects')
        self.ax_isolated_count.grid(True, alpha=0.3)
        
        self.canvas = FigureCanvasTkAgg(self.figure, master=plots_frame)
        self.canvas_widget = self.canvas.get_tk_widget()
        self.canvas_widget.pack(fill=tk.BOTH, expand=True)
    
    def _run_analysis(self) -> None:
        """Run statistical analysis on current data."""
        if not self.state.data.has_geometric_data:
            messagebox.showwarning(
                'No Data',
                'Please generate objects first using the Visualization tab.'
            )
            return
        
        try:
            self.log('Running statistical analysis...')
            
            scene = self.state.data.geometric_scene
            n_objects = len(scene)
            H, W = scene.field_shape
            
            # Get parameters
            a = self.box_size.get()
            k0 = self.box_threshold.get()
            m = self.neighbor_threshold.get()
            mode = self.count_mode.get()
            
            # Performance warnings for large datasets
            grid_H = H // a
            grid_W = W // a
            n_boxes = grid_H * grid_W
            
            # Warn if box grid is very large
            if n_boxes > 100000:
                response = messagebox.askyesno(
                    'Large Grid Warning',
                    f'Analysis will create {n_boxes:,} boxes ({grid_H}×{grid_W}).\n'
                    f'This may take 10-30 seconds.\n\n'
                    f'Tip: Increase box size (a) to {a*2} or {a*4} for faster analysis.\n\n'
                    f'Continue anyway?'
                )
                if not response:
                    self.log('Analysis cancelled by user')
                    return
            
            # Warn if object count is very high (overlap precomputation)
            if n_objects > 500000:
                self.log(f'Warning: {n_objects:,} objects may take 10-60s for overlap analysis...')
                messagebox.showinfo(
                    'Large Dataset',
                    f'Analyzing {n_objects:,} objects.\n'
                    f'Overlap precomputation may take 10-60 seconds.\n'
                    f'Please wait...'
                )
            
            # Get active policy
            active_policy = self.active_policy.get()
            
            self.log(f'Analyzing {n_objects:,} objects using {active_policy} policy...')
            
            # Run empirical analysis based on selected policy
            analyzer = CrowdingAnalyzer(scene)
            
            if active_policy == 'overlap':
                # Only overlap policy
                obj_result = analyzer.analyze_object_policy(m)
                results = {
                    **obj_result,
                    'policy': 'overlap',
                    'discarded_object_ids': obj_result['discarded_object_ids'],
                    'isolated_objects': obj_result['good_targets'],
                    'coverage_fraction': analyzer.compute_coverage_fraction_monte_carlo()
                }
            elif active_policy == 'box':
                # Only box crowding policy
                box_result = analyzer.analyze_box_crowding(a, k0, mode)
                results = {
                    **box_result,
                    'policy': 'box',
                    'discarded_object_ids': box_result['discarded_object_ids'],
                    'isolated_objects': box_result['good_targets'],
                    'coverage_fraction': analyzer.compute_coverage_fraction_monte_carlo()
                }
            else:
                raise ValueError(f"Unknown policy: {active_policy}")
            
            # Compute intensity from data
            H, W = scene.field_shape
            λ_empirical = len(scene) / (H * W)
            self.intensity.set(λ_empirical)
            
            # Build radius distribution from scene
            radii = [obj.radius for obj in scene.objects]
            if len(radii) > 0:
                # Use empirical statistics to inform distribution
                mean_r = np.mean(radii)
                std_r = np.std(radii)
                min_r = max(1.0, min(radii))
                max_r = max(radii)
                
                # Update UI with empirical values
                self.radius_mean.set(float(mean_r))
                self.radius_std.set(float(std_r))
                self.radius_min.set(float(min_r))
                self.radius_max.set(float(max_r))
            
            # Create theoretical model
            R_dist = RadiusDistribution(
                mean=self.radius_mean.get(),
                std=self.radius_std.get(),
                r_min=self.radius_min.get(),
                r_max=self.radius_max.get()
            )
            
            theory = BooleanModelTheory(λ_empirical, R_dist)
            
            # Compute theoretical predictions based on active policy
            coverage_theory = theory.coverage_probability()
            
            if active_policy == 'overlap':
                expected_good = theory.expected_good_count(len(scene), m)
            elif active_policy == 'box':
                # Box policy: approximate as (1 - p_crowded) * n
                p_crowded = theory.box_crowding_prob(a, k0, mode)
                expected_good = len(scene) * (1 - p_crowded)
            else:
                expected_good = 0.0
            
            # Update scoreboard
            self._update_scoreboard(results, expected_good)
            
            # Update plots
            self._update_plots(theory, results, λ_empirical)
            
            # Store results
            self.last_results = {
                **results,
                'expected_good': expected_good,
                'lambda': λ_empirical,
                'active_policy': active_policy,
            }
            
            self.log(f'Analysis complete: {results["isolated_objects"]} isolated objects found using {active_policy} policy')
            
        except Exception as e:
            messagebox.showerror('Analysis Error', f'Failed to run analysis:\n{str(e)}')
            self.log(f'Error: {str(e)}')
            import traceback
            traceback.print_exc()
    
    def _update_policy_visibility(self) -> None:
        """Show/hide UI elements based on selected policy."""
        policy = self.active_policy.get()
        
        if policy == 'overlap':
            # Show neighbor controls, hide box controls
            self.neighbor_frame.pack(fill=tk.X, padx=4, pady=4)
            self.box_frame.pack_forget()
            
            # Show neighbor metrics, hide box metrics
            self.neighbor_metrics_frame.grid()
            self.box_metrics_frame.grid_remove()
        else:  # box
            # Show box controls, hide neighbor controls
            self.box_frame.pack(fill=tk.X, padx=4, pady=4)
            self.neighbor_frame.pack_forget()
            
            # Show box metrics, hide neighbor metrics
            self.box_metrics_frame.grid()
            self.neighbor_metrics_frame.grid_remove()
    
    def _update_scoreboard(
        self,
        results: Dict[str, Any],
        expected_good: float
    ) -> None:
        """Update scoreboard labels with results."""
        # Common metrics
        self.metric_labels['total_objects'].config(text=str(results['total_objects']))
        
        # Policy-specific metrics
        policy = results.get('policy', 'overlap')
        if policy == 'box':
            self.metric_labels['crowded_boxes'].config(text=str(results.get('crowded_boxes', 0)))
            self.metric_labels['discarded_by_box'].config(text=str(results.get('discarded_by_box', 0)))
        else:  # overlap
            self.metric_labels['discarded_by_object'].config(text=str(results.get('discarded_by_object', 0)))
        
        # Shared result metrics
        self.metric_labels['isolated_objects'].config(text=str(results.get('isolated_objects', 0)))
        self.metric_labels['good_per_area_strict'].config(text=f"{results.get('good_per_area', 0.0):.6f}")
        self.metric_labels['coverage_fraction'].config(text=f"{results['coverage_fraction']:.4f}")
        
        # Theory comparison
        self.metric_labels['expected_good'].config(text=f"{expected_good:.1f}")
        self.metric_labels['actual_good'].config(text=str(results.get('isolated_objects', 0)))
    
    def _update_plots(
        self,
        theory: BooleanModelTheory,
        results: Dict[str, Any],
        λ_current: float
    ) -> None:
        """Update analysis plots with overlap probability analysis."""
        # Clear axes
        self.ax_survival_lambda.clear()
        self.ax_survival_threshold.clear()
        self.ax_isolated_count.clear()
        
        policy = results.get('policy', 'overlap')
        
        # Plot 1: Survival probability vs intensity (λ)
        λ_range = np.linspace(0.0001, λ_current * 2.5, 100)
        
        if policy == 'overlap':
            m = self.neighbor_threshold.get()
            survival_curve = []
            for λ in λ_range:
                theory_λ = BooleanModelTheory(λ=λ, R_dist=theory.R_dist)
                p_survive = theory_λ.palm_survival_probability(m)
                survival_curve.append(p_survive)
            
            # Calculate empirical survival
            p_survive_empirical = results.get('isolated_objects', 0) / max(1, results['total_objects'])
            
            self.ax_survival_lambda.plot(λ_range, survival_curve, 'b-', label=f'Theory (m={m})', linewidth=2)
            self.ax_survival_lambda.plot(
                [λ_current], [p_survive_empirical],
                'ro', markersize=10, label='Empirical'
            )
            self.ax_survival_lambda.set_title(f'Survival Probability vs Intensity (m={m})')
        else:  # box
            a = self.box_size.get()
            k0 = self.box_threshold.get()
            mode = self.count_mode.get()
            
            survival_curve = []
            for λ in λ_range:
                theory_λ = BooleanModelTheory(λ=λ, R_dist=theory.R_dist)
                p_crowded = theory_λ.box_crowding_prob(a, k0, mode)
                survival_curve.append(1 - p_crowded)
            
            # Calculate empirical survival
            p_survive_empirical = results.get('isolated_objects', 0) / max(1, results['total_objects'])
            
            self.ax_survival_lambda.plot(λ_range, survival_curve, 'b-', 
                                        label=f'Theory (a={a}, k₀={k0})', linewidth=2)
            self.ax_survival_lambda.plot(
                [λ_current], [p_survive_empirical],
                'ro', markersize=10, label='Empirical'
            )
            self.ax_survival_lambda.set_title(f'Survival Probability vs Intensity (a={a}, k₀={k0})')
        
        self.ax_survival_lambda.set_xlabel('Intensity λ (objects per px²)')
        self.ax_survival_lambda.set_ylabel('P(survive)')
        self.ax_survival_lambda.legend()
        self.ax_survival_lambda.grid(True, alpha=0.3)
        
        # Plot 2: Survival probability vs threshold parameter
        if policy == 'overlap':
            # Vary neighbor threshold m
            m_range = np.arange(1, 21)
            survival_curve = []
            for m_val in m_range:
                p_survive = theory.palm_survival_probability(int(m_val))
                survival_curve.append(p_survive)
            
            m_current = self.neighbor_threshold.get()
            p_survive_empirical = results.get('isolated_objects', 0) / max(1, results['total_objects'])
            
            self.ax_survival_threshold.plot(m_range, survival_curve, 'b-', 
                                           label=f'Theory (λ={λ_current:.6f})', linewidth=2)
            self.ax_survival_threshold.plot(
                [m_current], [p_survive_empirical],
                'ro', markersize=10, label='Empirical'
            )
            self.ax_survival_threshold.set_title(f'Survival Probability vs Neighbor Threshold (λ={λ_current:.6f})')
            self.ax_survival_threshold.set_xlabel('Neighbor threshold (m)')
        else:  # box
            # Vary occupancy threshold k0
            a = self.box_size.get()
            mode = self.count_mode.get()
            k0_range = np.arange(1, 21)
            survival_curve = []
            for k0_val in k0_range:
                p_crowded = theory.box_crowding_prob(a, int(k0_val), mode)
                survival_curve.append(1 - p_crowded)
            
            k0_current = self.box_threshold.get()
            p_survive_empirical = results.get('isolated_objects', 0) / max(1, results['total_objects'])
            
            self.ax_survival_threshold.plot(k0_range, survival_curve, 'b-',
                                           label=f'Theory (λ={λ_current:.6f}, a={a})', linewidth=2)
            self.ax_survival_threshold.plot(
                [k0_current], [p_survive_empirical],
                'ro', markersize=10, label='Empirical'
            )
            self.ax_survival_threshold.set_title(f'Survival Probability vs Occupancy Threshold (λ={λ_current:.6f})')
            self.ax_survival_threshold.set_xlabel('Occupancy threshold (k₀)')
        
        self.ax_survival_threshold.set_ylabel('P(survive)')
        self.ax_survival_threshold.legend()
        self.ax_survival_threshold.grid(True, alpha=0.3)
        
        # Plot 3: Isolated objects vs total count
        n_range = np.linspace(10, max(20.0, results['total_objects'] * 1.5), 100)
        
        # Compute area from current data
        H, W = self.state.data.geometric_scene.field_shape
        area_px2 = H * W
        
        # Compute theory curve based on active policy
        expected_good_curve = []
        if policy == 'overlap':
            m = self.neighbor_threshold.get()
            for n in n_range:
                λ_n = float(n) / area_px2
                theory_n = BooleanModelTheory(λ=λ_n, R_dist=theory.R_dist)
                p_survive_n = theory_n.palm_survival_probability(m)
                expected_good_curve.append(n * p_survive_n)
            theory_label = f'Theory (Neighbor Policy, m={m})'
        else:  # box policy
            a = self.box_size.get()
            k0 = self.box_threshold.get()
            mode = self.count_mode.get()
            for n in n_range:
                λ_n = float(n) / area_px2
                theory_n = BooleanModelTheory(λ=λ_n, R_dist=theory.R_dist)
                p_crowded = theory_n.box_crowding_prob(a, k0, mode)
                expected_good_curve.append(n * (1 - p_crowded))
            theory_label = f'Theory (Region Policy, a={a}, k₀={k0})'
        
        self.ax_isolated_count.plot(
            n_range,
            expected_good_curve,
            'b-',
            label=theory_label,
            linewidth=2
        )
        self.ax_isolated_count.plot(
            [results['total_objects']],
            [results.get('isolated_objects', 0)],
            'ro',
            markersize=10,
            label='Empirical'
        )
        self.ax_isolated_count.set_title('Isolated Objects vs Density')
        self.ax_isolated_count.set_xlabel('Total Objects (n)')
        self.ax_isolated_count.set_ylabel('Isolated Objects')
        self.ax_isolated_count.legend()
        self.ax_isolated_count.grid(True, alpha=0.3)
        
        self.canvas.draw()
    
    def _update_box_area_display(self) -> None:
        """Update the box area label when slider moves."""
        a = self.box_size.get()
        area = a * a
        self.box_area_label.config(text=f'{area} px²')
    
    def _auto_fit_from_scene(self) -> None:
        """Auto-fit ALL parameters (intensity + radius distribution) from current scene."""
        if not self.state.data.has_geometric_data:
            messagebox.showwarning(
                'No Data',
                'Please generate objects first to auto-fit parameters.'
            )
            return
        
        scene = self.state.data.geometric_scene
        if scene is None or len(scene) == 0:
            messagebox.showwarning('No Data', 'No objects in current scene.')
            return
        
        # Extract radii from scene
        radii = [obj.radius for obj in scene.objects]
        
        if len(radii) == 0:
            messagebox.showwarning('No Data', 'No radii found in objects.')
            return
        
        # Compute radius statistics
        mean_r = float(np.mean(radii))
        std_r = float(np.std(radii))
        min_r = float(max(1.0, min(radii)))
        max_r = float(max(radii))
        
        # Compute intensity (λ) from scene
        H, W = scene.field_shape
        λ_empirical = len(scene) / (H * W)
        
        # Update UI
        self.radius_mean.set(mean_r)
        self.radius_std.set(std_r)
        self.radius_min.set(min_r)
        self.radius_max.set(max_r)
        self.intensity.set(λ_empirical)
        
        # Update status label
        self.fitted_status_label.config(
            text=f'✓ Fitted: λ={λ_empirical:.6f}, μ_R={mean_r:.2f}, σ_R={std_r:.2f}'
        )
        
        self.log(f'Auto-fit complete: λ={λ_empirical:.6f}, μ={mean_r:.2f}, σ={std_r:.2f}')
        messagebox.showinfo(
            'Auto-Fit Complete',
            f'All parameters fitted from scene:\n\n'
            f'Spatial intensity (λ): {λ_empirical:.6f} obj/px²\n'
            f'Radius mean (μ): {mean_r:.2f} px\n'
            f'Radius std (σ): {std_r:.2f} px\n'
            f'Radius range: [{min_r:.2f}, {max_r:.2f}] px'
        )
    
    def _export_csv(self) -> None:
        """Export results to CSV."""
        if self.last_results is None:
            messagebox.showwarning('No Results', 'Run analysis first before exporting.')
            return
        
        from tkinter import filedialog
        import pandas as pd
        
        filepath = filedialog.asksaveasfilename(
            defaultextension='.csv',
            filetypes=[('CSV files', '*.csv'), ('All files', '*.*')]
        )
        
        if not filepath:
            return
        
        try:
            # Create DataFrame with results
            df = pd.DataFrame([self.last_results])
            df.to_csv(filepath, index=False)
            self.log(f'Results exported to {filepath}')
            messagebox.showinfo('Export Success', f'Results saved to:\n{filepath}')
        except Exception as e:
            messagebox.showerror('Export Error', f'Failed to export:\n{str(e)}')
    
    def _view_discarded(self) -> None:
        """Open Inspector with discarded objects (sorted appropriately)."""
        if self.last_results is None or self.open_inspector is None:
            messagebox.showwarning('No Results', 'Run analysis first.')
            return
        
        scene = self.state.data.geometric_scene
        policy = self.last_results.get('active_policy', 'overlap')
        
        discarded_ids = list(self.last_results['discarded_object_ids'])
        
        # Sort based on policy
        if policy == 'overlap' and 'neighbor_counts' in self.last_results:
            # Sort by neighbor count (most overlapped first)
            neighbor_counts = self.last_results['neighbor_counts']
            discarded_with_counts = [
                (obj.id, neighbor_counts[i]) 
                for i, obj in enumerate(scene.objects) 
                if obj.id in discarded_ids
            ]
            discarded_with_counts.sort(key=lambda x: x[1], reverse=True)
            discarded_ids_sorted = [obj_id for obj_id, _ in discarded_with_counts]
            sort_desc = 'sorted by overlap count'
        else:
            # Box policy - just use IDs as is
            discarded_ids_sorted = discarded_ids
            sort_desc = ''
        
        self.open_inspector(discarded_ids_sorted)
        self.log(f'Opening inspector with {len(discarded_ids_sorted)} discarded objects ({policy} policy) {sort_desc}')
    
    def _view_good(self) -> None:
        """Open Inspector with isolated objects (sorted appropriately)."""
        if self.last_results is None or self.open_inspector is None:
            messagebox.showwarning('No Results', 'Run analysis first.')
            return
        
        scene = self.state.data.geometric_scene
        if scene is None:
            return
        
        policy = self.last_results.get('active_policy', 'overlap')
        discarded_ids = self.last_results['discarded_object_ids']
        
        # Get isolated object IDs
        isolated_ids = [obj.id for obj in scene.objects if obj.id not in discarded_ids]
        
        # Sort based on policy
        if policy == 'overlap' and 'neighbor_counts' in self.last_results:
            # Sort by neighbor count (ascending - least overlapped first)
            neighbor_counts = self.last_results['neighbor_counts']
            isolated_with_counts = [
                (obj.id, neighbor_counts[i])
                for i, obj in enumerate(scene.objects)
                if obj.id not in discarded_ids
            ]
            isolated_with_counts.sort(key=lambda x: x[1])
            isolated_ids_sorted = [obj_id for obj_id, _ in isolated_with_counts]
            sort_desc = 'sorted by overlap count'
        else:
            # Box policy - just use IDs as is
            isolated_ids_sorted = isolated_ids
            sort_desc = ''
        
        self.open_inspector(isolated_ids_sorted)
        self.log(f'Opening inspector with {len(isolated_ids_sorted)} isolated objects ({policy} policy) {sort_desc}')


